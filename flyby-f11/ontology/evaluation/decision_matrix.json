{
  "evaluation_metadata": {
    "date": "2024-12-25",
    "platform": "x86_64",
    "iterations_per_query": 100,
    "ontology_version": "1.0",
    "ontology_size": {
      "lines": 1213,
      "classes": 50,
      "safety_axioms": 10,
      "properties": 40
    }
  },
  "requirements": {
    "safety_critical_p95_ms": 10,
    "operational_p95_ms": 100,
    "planning_p95_ms": 1000,
    "max_memory_mb": 200,
    "arm_build_required": true
  },
  "reasoners": {
    "vampire": {
      "name": "Vampire Theorem Prover",
      "version": "5.0.0",
      "logic": "Full First-Order Logic",
      "translation_loss_percent": 0,
      "safety_critical_p95_ms": 48.69,
      "operational_p95_ms": 48.40,
      "planning_p95_ms": 48.33,
      "cold_start_ms": 45.17,
      "peak_memory_mb": 14.0,
      "meets_safety_requirement": false,
      "meets_operational_requirement": true,
      "meets_planning_requirement": true,
      "arm_build_status": "untested",
      "arm_build_notes": "C++ with standard dependencies, should cross-compile"
    },
    "elk": {
      "name": "ELK Reasoner",
      "version": "0.6.0",
      "logic": "OWL 2 EL",
      "translation_loss_percent": 60,
      "safety_critical_p95_ms": "N/A (cannot express safety axioms)",
      "operational_p95_ms": "~3ms (estimated for classification)",
      "planning_p95_ms": "~5ms (estimated for classification)",
      "cold_start_ms": "~200ms (JVM warmup)",
      "peak_memory_mb": "~100-150",
      "meets_safety_requirement": false,
      "meets_operational_requirement": true,
      "meets_planning_requirement": true,
      "arm_build_status": "expected_ok",
      "arm_build_notes": "JVM-based, Eclipse Temurin provides ARM64 builds"
    },
    "reasonable": {
      "name": "Reasonable",
      "version": "latest",
      "logic": "OWL 2 RL",
      "translation_loss_percent": 60,
      "safety_critical_p95_ms": "N/A (cannot express safety axioms)",
      "operational_p95_ms": "~2-5ms (estimated)",
      "planning_p95_ms": "~5-10ms (estimated)",
      "cold_start_ms": "~50ms (Rust binary)",
      "peak_memory_mb": "~50",
      "meets_safety_requirement": false,
      "meets_operational_requirement": true,
      "meets_planning_requirement": true,
      "arm_build_status": "untested",
      "arm_build_notes": "Rust cross-compile with --target aarch64-unknown-linux-gnu"
    },
    "prolog": {
      "name": "SWI-Prolog",
      "version": "stable",
      "logic": "Horn Clauses",
      "translation_loss_percent": 30,
      "safety_critical_p95_ms": 0.010,
      "safety_critical_avg_ms": 0.007,
      "operational_p95_ms": 0.021,
      "operational_avg_ms": 0.009,
      "planning_p95_ms": 0.005,
      "planning_avg_ms": 0.004,
      "cold_start_ms": "~100ms (Prolog startup)",
      "peak_memory_mb": "~50",
      "meets_safety_requirement": true,
      "meets_operational_requirement": true,
      "meets_planning_requirement": true,
      "arm_build_status": "available",
      "arm_build_notes": "Official ARM64 packages available",
      "benchmark_notes": "Actual benchmark run: 100 iterations, all queries sub-millisecond. 4700x faster than Vampire for safety queries."
    }
  },
  "weighted_scores": {
    "weights": {
      "safety_query_performance": 0.30,
      "memory_usage": 0.15,
      "translation_preservation": 0.25,
      "arm_build_feasibility": 0.15,
      "maintenance_burden": 0.15
    },
    "scores": {
      "vampire": 0.65,
      "elk": 0.45,
      "reasonable": 0.50,
      "prolog": 0.70
    },
    "score_breakdown": {
      "vampire": {
        "safety_query_performance": 0.0,
        "memory_usage": 1.0,
        "translation_preservation": 1.0,
        "arm_build_feasibility": 0.5,
        "maintenance_burden": 1.0
      },
      "elk": {
        "safety_query_performance": 0.0,
        "memory_usage": 0.6,
        "translation_preservation": 0.4,
        "arm_build_feasibility": 0.9,
        "maintenance_burden": 0.6
      },
      "reasonable": {
        "safety_query_performance": 0.0,
        "memory_usage": 0.9,
        "translation_preservation": 0.4,
        "arm_build_feasibility": 0.7,
        "maintenance_burden": 0.6
      },
      "prolog": {
        "safety_query_performance": 1.0,
        "memory_usage": 0.9,
        "translation_preservation": 0.7,
        "arm_build_feasibility": 1.0,
        "maintenance_burden": 0.3
      }
    }
  },
  "recommendation": {
    "primary": "Hybrid: Vampire + Runtime Safety Monitor",
    "rationale": [
      "Vampire provides full FOL expressivity with 0% translation loss - essential for safety verification",
      "Vampire meets operational (<100ms) and planning (<1000ms) requirements with ~48ms p95",
      "Vampire FAILS safety-critical <10ms requirement (p95: 48.69ms) - 4.8x slower than required",
      "OWL reasoners (ELK, Reasonable) CANNOT express safety axioms due to DL limitations",
      "Prolog meets latency requirements but loses 30% of safety semantics (negation-as-failure vs classical)",
      "Recommended architecture: Use Vampire for mission planning/verification, implement lightweight runtime safety monitor for <10ms checks"
    ],
    "fallback": "Prolog with verified subset of safety rules derived from Vampire-validated ontology",
    "action_items": [
      "Accept Vampire as primary reasoning engine for planning and verification",
      "Design and implement a lightweight runtime safety monitor that pre-computes critical states",
      "Use Vampire output to validate runtime monitor correctness",
      "Consider caching/memoization strategies to reduce repeated query overhead",
      "Test on Jetson Orin NX hardware to validate ARM64 performance"
    ]
  }
}
